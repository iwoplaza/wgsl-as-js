{"version":3,"sources":["../src/wgsl.ts"],"sourcesContent":["import type { Infer, InferRecord } from \"./infer\";\nimport type {\n\tv2f,\n\tv2i,\n\tv2u,\n\tv3f,\n\tv3i,\n\tv3u,\n\tv4f,\n\tv4i,\n\tv4u,\n\tm2x2f,\n\tm3x3f,\n\tm4x4f,\n} from \"./instance\";\n\nexport interface BaseWgslData {\n\ttype: string;\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": unknown;\n}\n\nexport type ExtractInner<T> = T extends { readonly inner: BaseWgslData }\n\t? T[\"inner\"]\n\t: never;\nexport type ExtractAttribs<T> = T extends { readonly attribs: unknown[] }\n\t? T[\"attribs\"]\n\t: [];\n\n// #region WGSL Schema Types\n\n/**\n * Boolean schema representing a single WGSL bool value.\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Bool {\n\treadonly type: \"bool\";\n\treadonly \"~repr\": boolean;\n}\n\nexport interface F32 {\n\treadonly type: \"f32\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": number;\n}\n\nexport interface I32 {\n\treadonly type: \"i32\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": number;\n}\n\nexport interface U32 {\n\treadonly type: \"u32\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": number;\n}\n\nexport interface Vec2f {\n\treadonly type: \"vec2f\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v2f;\n}\n\nexport interface Vec2i {\n\treadonly type: \"vec2i\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v2i;\n}\n\nexport interface Vec2u {\n\treadonly type: \"vec2u\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v2u;\n}\n\nexport interface Vec3f {\n\treadonly type: \"vec3f\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v3f;\n}\n\nexport interface Vec3i {\n\treadonly type: \"vec3i\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v3i;\n}\n\nexport interface Vec3u {\n\treadonly type: \"vec3u\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v3u;\n}\n\nexport interface Vec4f {\n\treadonly type: \"vec4f\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v4f;\n}\n\nexport interface Vec4i {\n\treadonly type: \"vec4i\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v4i;\n}\n\nexport interface Vec4u {\n\treadonly type: \"vec4u\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": v4u;\n}\n\nexport interface Mat2x2f {\n\treadonly type: \"mat2x2f\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": m2x2f;\n}\n\nexport interface Mat3x3f {\n\treadonly type: \"mat3x3f\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": m3x3f;\n}\n\nexport interface Mat4x4f {\n\treadonly type: \"mat4x4f\";\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": m4x4f;\n}\n\nexport interface WgslStruct<\n\tTProps extends Record<string, BaseWgslData> = Record<string, BaseWgslData>,\n> {\n\treadonly type: \"struct\";\n\treadonly label?: string | undefined;\n\treadonly propTypes: TProps;\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": InferRecord<TProps>;\n}\n\nexport interface WgslArray<TElement = BaseWgslData> {\n\treadonly type: \"array\";\n\treadonly length: number;\n\treadonly elementType: TElement;\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": Infer<TElement>[];\n}\n\n/**\n * Schema representing the `atomic<...>` WGSL data type.\n */\nexport interface Atomic<TInner extends U32 | I32 = U32 | I32> {\n\treadonly type: \"atomic\";\n\treadonly inner: TInner;\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": Infer<TInner>;\n}\n\nexport interface Align<T extends number> {\n\treadonly type: \"@align\";\n\treadonly value: T;\n}\n\nexport interface Size<T extends number> {\n\treadonly type: \"@size\";\n\treadonly value: T;\n}\n\nexport interface Location<T extends number> {\n\treadonly type: \"@location\";\n\treadonly value: T;\n}\n\nexport interface Builtin<T extends string> {\n\treadonly type: \"@builtin\";\n\treadonly value: T;\n}\n\nexport interface Decorated<\n\tTInner extends BaseWgslData = BaseWgslData,\n\tTAttribs extends unknown[] = unknown[],\n> {\n\treadonly type: \"decorated\";\n\treadonly inner: TInner;\n\treadonly attribs: TAttribs;\n\t/** Type-token, not available at runtime */\n\treadonly \"~repr\": Infer<TInner>;\n}\n\nexport const wgslTypeLiterals = [\n\t\"bool\",\n\t\"f32\",\n\t\"i32\",\n\t\"u32\",\n\t\"vec2f\",\n\t\"vec2i\",\n\t\"vec2u\",\n\t\"vec3f\",\n\t\"vec3i\",\n\t\"vec3u\",\n\t\"vec4f\",\n\t\"vec4i\",\n\t\"vec4u\",\n\t\"mat2x2f\",\n\t\"mat3x3f\",\n\t\"mat4x4f\",\n\t\"struct\",\n\t\"array\",\n\t\"atomic\",\n\t\"decorated\",\n] as const;\n\nexport type WgslTypeLiteral = (typeof wgslTypeLiterals)[number];\n\nexport type AnyWgslData =\n\t| Bool\n\t| F32\n\t| I32\n\t| U32\n\t| Vec2f\n\t| Vec2i\n\t| Vec2u\n\t| Vec3f\n\t| Vec3i\n\t| Vec3u\n\t| Vec4f\n\t| Vec4i\n\t| Vec4u\n\t| Mat2x2f\n\t| Mat3x3f\n\t| Mat4x4f\n\t| WgslStruct\n\t| WgslArray\n\t| Atomic\n\t| Decorated;\n\n// #endregion\n\n// #region Type Narrowing Functions\n\nexport function isWgslData(value: unknown): value is AnyWgslData {\n\treturn wgslTypeLiterals.includes((value as AnyWgslData)?.type);\n}\n\n/**\n * Checks whether passed in value is an array schema,\n * as opposed to, e.g., a looseArray schema.\n *\n * Array schemas can be used to describe uniform and storage buffers,\n * whereas looseArray schemas cannot.\n *\n * @example\n * isWgslArray(d.arrayOf(d.u32, 4)) // true\n * isWgslArray(d.looseArrayOf(d.u32, 4)) // false\n * isWgslArray(d.vec3f) // false\n */\nexport function isWgslArray<T extends WgslArray>(\n\tschema: T | unknown,\n): schema is T {\n\treturn (schema as T)?.type === \"array\";\n}\n\n/**\n * Checks whether passed in value is a struct schema,\n * as opposed to, e.g., a looseStruct schema.\n *\n * Struct schemas can be used to describe uniform and storage buffers,\n * whereas looseStruct schemas cannot.\n *\n * @example\n * isWgslStruct(d.struct({ a: d.u32 })) // true\n * isWgslStruct(d.looseStruct({ a: d.u32 })) // false\n * isWgslStruct(d.vec3f) // false\n */\nexport function isWgslStruct<T extends WgslStruct>(\n\tschema: T | unknown,\n): schema is T {\n\treturn (schema as T)?.type === \"struct\";\n}\n\n/**\n * Checks whether the passed in value is an atomic schema.\n *\n * @example\n * isAtomic(d.atomic(d.u32)) // true\n * isAtomic(d.u32) // false\n */\nexport function isAtomic<T extends Atomic<U32 | I32>>(\n\tschema: T | unknown,\n): schema is T {\n\treturn (schema as T)?.type === \"atomic\";\n}\n\nexport function isAlignAttrib<T extends Align<number>>(\n\tvalue: unknown | T,\n): value is T {\n\treturn (value as T)?.type === \"@align\";\n}\n\nexport function isSizeAttrib<T extends Size<number>>(\n\tvalue: unknown | T,\n): value is T {\n\treturn (value as T)?.type === \"@size\";\n}\n\nexport function isLocationAttrib<T extends Location<number>>(\n\tvalue: unknown | T,\n): value is T {\n\treturn (value as T)?.type === \"@location\";\n}\n\nexport function isBuiltinAttrib<T extends Builtin<string>>(\n\tvalue: unknown | T,\n): value is T {\n\treturn (value as T)?.type === \"@builtin\";\n}\n\nexport function isDecorated<T extends Decorated>(\n\tvalue: unknown | T,\n): value is T {\n\treturn (value as T)?.type === \"decorated\";\n}\n\n// #endregion\n\n// #region Schemas / Schema Constructors\n\nexport const bool = { type: \"bool\" } as Bool;\nexport const f32 = { type: \"f32\" } as F32;\nexport const i32 = { type: \"i32\" } as I32;\nexport const u32 = { type: \"u32\" } as U32;\nexport const vec2f = { type: \"vec2f\" } as Vec2f;\nexport const vec2i = { type: \"vec2i\" } as Vec2i;\nexport const vec2u = { type: \"vec2u\" } as Vec2u;\nexport const vec3f = { type: \"vec3f\" } as Vec3f;\nexport const vec3i = { type: \"vec3i\" } as Vec3i;\nexport const vec3u = { type: \"vec3u\" } as Vec3u;\nexport const vec4f = { type: \"vec4f\" } as Vec4f;\nexport const vec4i = { type: \"vec4i\" } as Vec4i;\nexport const vec4u = { type: \"vec3u\" } as Vec3u;\nexport const mat2x2f = { type: \"mat2x2f\" } as Mat2x2f;\nexport const mat3x3f = { type: \"mat3x3f\" } as Mat3x3f;\nexport const mat4x4f = { type: \"mat4x4f\" } as Mat4x4f;\n\nexport const struct = <TProps extends Record<string, BaseWgslData>>(\n\tlabel: string | undefined,\n\tpropTypes: TProps,\n): WgslStruct<TProps> =>\n\t({ type: \"struct\", label, propTypes }) as WgslStruct<TProps>;\n\nexport const array = <TElement>(\n\telementType: TElement,\n\tlength: number,\n): WgslArray<TElement> =>\n\t({ type: \"array\", elementType, length }) as WgslArray<TElement>;\n\nconst knownAtomics = {\n\ti32: { type: \"atomic\", inner: i32 } as Atomic<I32>,\n\tu32: { type: \"atomic\", inner: u32 } as Atomic<U32>,\n};\n\nexport const atomic = (inner: U32 | I32) => knownAtomics[inner.type];\n\nexport const decorated = <TData extends BaseWgslData, TAttrib>(\n\tinner: TData,\n\tattrib: TAttrib,\n): Decorated<ExtractInner<TData>, [...ExtractAttribs<TData>, TAttrib]> =>\n\t({\n\t\ttype: \"decorated\",\n\t\tinner,\n\t\tattribs: [...((inner as any)?.attribs ?? []), attrib],\n\t}) as any;\n\n// #endregion\n"],"mappings":";AA6LO,IAAM,mBAAmB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AA8BO,SAAS,WAAW,OAAsC;AAChE,SAAO,iBAAiB,SAAU,+BAAuB,IAAI;AAC9D;AAcO,SAAS,YACf,QACc;AACd,UAAQ,iCAAc,UAAS;AAChC;AAcO,SAAS,aACf,QACc;AACd,UAAQ,iCAAc,UAAS;AAChC;AASO,SAAS,SACf,QACc;AACd,UAAQ,iCAAc,UAAS;AAChC;AAEO,SAAS,cACf,OACa;AACb,UAAQ,+BAAa,UAAS;AAC/B;AAEO,SAAS,aACf,OACa;AACb,UAAQ,+BAAa,UAAS;AAC/B;AAEO,SAAS,iBACf,OACa;AACb,UAAQ,+BAAa,UAAS;AAC/B;AAEO,SAAS,gBACf,OACa;AACb,UAAQ,+BAAa,UAAS;AAC/B;AAEO,SAAS,YACf,OACa;AACb,UAAQ,+BAAa,UAAS;AAC/B;AAMO,IAAM,OAAO,EAAE,MAAM,OAAO;AAC5B,IAAM,MAAM,EAAE,MAAM,MAAM;AAC1B,IAAM,MAAM,EAAE,MAAM,MAAM;AAC1B,IAAM,MAAM,EAAE,MAAM,MAAM;AAC1B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,IAAM,UAAU,EAAE,MAAM,UAAU;AAClC,IAAM,UAAU,EAAE,MAAM,UAAU;AAClC,IAAM,UAAU,EAAE,MAAM,UAAU;AAElC,IAAM,SAAS,CACrB,OACA,eAEC,EAAE,MAAM,UAAU,OAAO,UAAU;AAE9B,IAAM,QAAQ,CACpB,aACA,YAEC,EAAE,MAAM,SAAS,aAAa,OAAO;AAEvC,IAAM,eAAe;AAAA,EACpB,KAAK,EAAE,MAAM,UAAU,OAAO,IAAI;AAAA,EAClC,KAAK,EAAE,MAAM,UAAU,OAAO,IAAI;AACnC;AAEO,IAAM,SAAS,CAAC,UAAqB,aAAa,MAAM,IAAI;AAE5D,IAAM,YAAY,CACxB,OACA,WACsE;AA9WvE;AA+WE;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA,SAAS,CAAC,IAAK,oCAAe,YAAf,YAA0B,CAAC,GAAI,MAAM;AAAA,EACrD;AAAA;","names":[]}